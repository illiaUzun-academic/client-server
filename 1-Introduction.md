### Лекція 1: Вступ до клієнт-серверної архітектури



### Вступ

Шановні студенти,

Вітаю вас на курсі "Розробка клієнт-серверних застосувань". Цей курс є фундаментальною частиною вашої підготовки в області комп'ютерних наук, оскільки клієнт-серверна архітектура є основою для розробки більшості сучасних інформаційних систем. Метою нашого курсу є надати вам всебічне розуміння концепцій, принципів і технологій, необхідних для проектування, розробки, впровадження та підтримки клієнт-серверних систем. Протягом курсу ми будемо вивчати основи цієї архітектури, розглядати ключові компоненти клієнт-серверних систем, аналізувати сучасні протоколи комунікації, а також поглиблено досліджувати різні підходи до розробки, тестування та оптимізації таких систем.

Після завершення курсу ви будете володіти необхідними знаннями та навичками для успішної розробки клієнт-серверних застосувань, що відповідають сучасним стандартам якості та безпеки.

#### Значення клієнт-серверної архітектури в сучасних системах

Клієнт-серверна архітектура є ключовою парадигмою в сучасному програмному забезпеченні, яка дозволяє реалізовувати розподілені системи з чітко визначеними ролями клієнта і сервера. У цій архітектурі клієнт виступає як ініціатор запитів, а сервер відповідає за обробку цих запитів і повернення результатів клієнту. Такий підхід забезпечує високу гнучкість, масштабованість та ефективність в умовах зростання обсягів даних і складності операцій.

Сучасні інформаційні системи, такі як веб-додатки, мобільні додатки, корпоративні системи, покладаються на клієнт-серверну архітектуру для забезпечення стабільної та безперебійної роботи. Наприклад, у веб-додатках клієнтська частина, що виконується в браузері користувача, взаємодіє з сервером, на якому зберігаються та обробляються дані. Ця модель дозволяє розробникам створювати динамічні та інтерактивні користувацькі інтерфейси, які можуть ефективно реагувати на дії користувача та змінюватися в реальному часі.

Клієнт-серверна архітектура також забезпечує підвищений рівень безпеки, оскільки серверна частина контролює доступ до даних і виконує критичні операції, зберігаючи чутливу інформацію поза доступом клієнта. Це дозволяє захищати дані від несанкціонованого доступу та зловмисних атак, що особливо важливо в корпоративних системах, де безпека даних є пріоритетом.

#### Приклади застосувань (веб-додатки, мобільні додатки, корпоративні системи)

Клієнт-серверна архітектура знаходить своє застосування в різних типах сучасних додатків, серед яких:

1. **Веб-додатки**:
   - Такі системи, як Google Docs, GitHub або будь-який інтернет-магазин, побудовані на клієнт-серверній архітектурі, де веб-браузер клієнта взаємодіє з віддаленим сервером для отримання і передачі даних. Веб-додатки дозволяють користувачам виконувати складні операції, такі як редагування документів, управління репозиторіями коду або здійснення покупок онлайн, через простий інтерфейс, що виконується на клієнтському комп'ютері.
2. **Мобільні додатки**:
   - Більшість сучасних мобільних додатків, таких як Instagram, Uber, або мобільні банківські застосунки, є яскравими прикладами клієнт-серверної архітектури. В таких додатках клієнтська частина працює на смартфоні або планшеті користувача, взаємодіючи з серверною частиною, яка забезпечує обробку запитів, зберігання даних і виконання складних обчислень.
3. **Корпоративні системи**:
   - Великі корпоративні інформаційні системи, такі як CRM (Customer Relationship Management) або ERP (Enterprise Resource Planning) системи, також побудовані на основі клієнт-серверної архітектури. В таких системах сервери обробляють величезні обсяги даних і забезпечують доступ до них для численних клієнтських додатків, які можуть бути розташовані як у межах однієї компанії, так і в різних географічних регіонах.

Клієнт-серверна архітектура є основою для створення розподілених систем, що дозволяють ефективно управляти великими обсягами даних, забезпечувати високу доступність та масштабованість, а також гарантувати безпеку і надійність інформації. Вивчення цієї архітектури відкриє вам шлях до розуміння того, як побудовані і функціонують більшість сучасних програмних рішень, і допоможе вам стати професіоналом у сфері розробки інформаційних систем.



### Основи клієнт-серверної архітектури

#### Визначення клієнт-серверної архітектури

Клієнт-серверна архітектура є однією з найпоширеніших моделей організації програмних систем, яка передбачає розподіл обов’язків між двома основними компонентами: клієнтом і сервером.

- **Клієнт** — це компонент, який ініціює запит на виконання певної операції, наприклад, запит на отримання даних або виконання певної дії. Клієнт може бути представлений у вигляді веб-браузера, мобільного додатка, настільного програмного забезпечення або будь-якого іншого інтерфейсу, що взаємодіє з сервером.
- **Сервер** — це компонент, який отримує запити від клієнта, обробляє їх та повертає відповідь. Сервер відповідає за зберігання, обробку та управління даними, а також за забезпечення виконання бізнес-логіки. Сервер може бути веб-сервером, сервером баз даних, файловим сервером або іншим сервером, що забезпечує доступ до ресурсів і послуг.

Клієнт-серверна архітектура передбачає чіткий поділ обов'язків між клієнтською частиною, яка виконується на пристрої користувача, та серверною частиною, яка знаходиться в центрі управління даними та логікою. Ця модель забезпечує масштабованість, безпеку та ефективність обробки запитів, дозволяючи підтримувати великий обсяг одночасних користувачів і запитів.

#### Історія та еволюція клієнт-серверних систем

Клієнт-серверна архітектура виникла як відповідь на обмеження, що були властиві ранішим обчислювальним моделям, таким як мейнфрейми та централізовані обчислення.

- **Мейнфрейми** (1950-ті – 1970-ті роки): На початку розвитку обчислювальних систем усі обчислення здійснювалися на великих централізованих комп'ютерах, відомих як мейнфрейми. Користувачі підключалися до мейнфрейму через термінали, що були лише інтерфейсами для введення даних і отримання результатів. Всі обчислення, зберігання даних та управління відбувалося виключно на мейнфреймі. Хоча ця модель була ефективною для тогочасних обчислювальних потреб, вона мала значні обмеження в масштабованості та гнучкості.
- **Зміна парадигми** (1980-ті – 1990-ті роки): З розвитком персональних комп'ютерів та локальних мереж виникла потреба в більш децентралізованій моделі обчислень. З'являється клієнт-серверна архітектура, яка дозволяє використовувати переваги потужних серверів для обробки даних, залишаючи при цьому частину обчислень і обробки на стороні клієнта. Це забезпечило більшу гнучкість та можливість обслуговувати більше користувачів без необхідності значного збільшення потужностей центрального сервера.
- **Розвиток Інтернету** (1990-ті – 2000-ні роки): З поширенням Інтернету клієнт-серверна архітектура стала основою для створення веб-додатків. Сервери почали надавати доступ до інформації через веб-інтерфейси, що дозволило мільйонам користувачів взаємодіяти з однією системою одночасно. Це призвело до виникнення нових технологій, таких як HTTP-протокол, веб-сервери (наприклад, Apache) та мови програмування для веб-розробки (наприклад, PHP, JavaScript).
- **Модернізація та розширення** (2000-ті – теперішній час): З розвитком хмарних технологій, мобільних пристроїв та мікросервісів клієнт-серверна архітектура продовжує еволюціонувати. Відбувається інтеграція нових підходів, таких як серверлес-обчислення, де частина обчислень перенесена на хмарні сервіси, а також з'являються нові формати комунікації, такі як WebSocket, що забезпечують реальний час взаємодії між клієнтами і серверами.

#### Ключові переваги клієнт-серверної архітектури

Клієнт-серверна архітектура має кілька суттєвих переваг, які роблять її популярною в сучасному програмному забезпеченні:

1. **Масштабованість**: Клієнт-серверна архітектура дозволяє легко масштабувати систему, додаючи нові сервери для обробки зростаючого навантаження. Це особливо важливо для великих корпоративних систем та інтернет-сервісів, які повинні підтримувати велику кількість користувачів.
2. **Розподіл навантаження**: В цій архітектурі навантаження розподіляється між клієнтом та сервером, що дозволяє зменшити навантаження на центральний сервер і підвищити загальну продуктивність системи.
3. **Гнучкість та модульність**: Завдяки розподіленій природі клієнт-серверної архітектури, різні компоненти системи можна розробляти, розгортати та оновлювати незалежно один від одного. Це спрощує підтримку і розвиток системи, а також дозволяє використовувати різні технології на клієнті та сервері.
4. **Безпека**: У клієнт-серверній архітектурі основна частина обробки даних і зберігання критичних даних виконується на сервері, що дозволяє централізовано контролювати доступ і забезпечувати захист інформації.
5. **Централізоване управління даними**: Сервер забезпечує єдину точку доступу до даних, що спрощує управління та підтримку актуальності інформації. Це особливо важливо для корпоративних систем, де потрібно зберігати та обробляти великі обсяги даних.
6. **Забезпечення стабільності та надійності**: Клієнт-серверні системи можуть бути спроектовані таким чином, щоб забезпечити високу відмовостійкість і стабільність роботи, використовуючи методи резервування, балансування навантаження та інші технології.

Таким чином, клієнт-серверна архітектура є фундаментальним підходом у сучасному програмуванні, що забезпечує високу ефективність, гнучкість і безпеку програмних систем, що робить її незамінною для створення складних та масштабованих застосунків.



### Інші типи програмних архітектур: порівняння з клієнт-серверною моделлю

У розробці програмного забезпечення існує багато різних архітектурних підходів, кожен з яких має свої особливості, переваги та недоліки. Розуміння цих архітектур допомагає вибрати найбільш підходящий підхід для конкретного проєкту, враховуючи його вимоги та обмеження. Нижче розглянемо основні типи архітектур, їх характеристики та порівняння з клієнт-серверною моделлю.

------

#### 1. **Монолітна архітектура**

**Опис:** Монолітна архітектура передбачає, що всі компоненти застосунку об'єднані в єдине цілісне додаток. Усі функціональні можливості, бізнес-логіка та інтерфейси користувача розміщені та виконуються в одному середовищі.

**Відмінності від клієнт-серверної архітектури:**

- У монолітній архітектурі всі компоненти тісно пов'язані між собою і виконуються як єдине ціле, тоді як у клієнт-серверній архітектурі функціональність розподілена між клієнтами та серверами.
- Монолітні системи зазвичай працюють на одному сервері або середовищі виконання, тоді як клієнт-серверні системи можуть бути розподілені по різних машинах і мережах.

**Переваги:**

- **Простота розробки та розгортання:** Менша складність архітектури спрощує процес розробки та тестування.
- **Висока продуктивність всередині процесу:** Відсутність мережевих викликів між компонентами забезпечує швидку взаємодію.
- **Легкість тестування:** Оскільки всі компоненти знаходяться в одному місці, тестування стає більш прямолінійним.

**Недоліки:**

- **Складність масштабування:** Масштабування моноліту зазвичай означає масштабування всього додатку, що може бути неефективним.
- **Труднощі в підтримці та оновленні:** Зміни в одній частині системи можуть впливати на інші частини, що ускладнює підтримку.
- **Обмежена гнучкість:** Важко інтегрувати нові технології або модулі без переробки значної частини системи.
- **Надійність:** Помилка в одній частині додатку може призвести до відмови всього застосунку.

------

#### 2. **Peer-to-Peer (P2P) архітектура**

**Опис:** У Peer-to-Peer архітектурі всі вузли мережі рівноправні та можуть виступати як клієнтами, так і серверами одночасно. Кожен вузол може ініціювати або обробляти запити, обмінюючись ресурсами та інформацією без центрального координатора.

**Відмінності від клієнт-серверної архітектури:**

- **Децентралізація:** У P2P немає центрального сервера; всі вузли рівноправні, тоді як у клієнт-серверній моделі є чіткий поділ ролей між клієнтом і сервером.
- **Розподіл навантаження:** Навантаження розподіляється між усіма учасниками мережі, а не концентрується на сервері.

**Переваги:**

- **Висока стійкість:** Відсутність центрального сервера означає, що відмова одного або кількох вузлів не вплине на роботу всієї мережі.
- **Масштабованість:** Додавання нових вузлів збільшує загальну потужність та пропускну здатність мережі.
- **Ефективне використання ресурсів:** Кожен вузол надає свої ресурси іншим, що дозволяє ефективно використовувати доступні потужності.

**Недоліки:**

- **Безпека:** Відсутність централізованого контролю ускладнює забезпечення безпеки та автентичності даних.
- **Контроль якості сервісу:** Важко гарантувати стабільну якість обслуговування через різноманітність та змінність ресурсів вузлів.
- **Складність пошуку ресурсів:** Без централізованого індексу пошук специфічних ресурсів може бути повільним або неефективним.
- **Юридичні та етичні питання:** P2P мережі часто асоціюються з нелегальним розповсюдженням контенту, що може призвести до юридичних проблем.

------

#### 3. **Мікросервісна архітектура**

**Опис:** Мікросервісна архітектура розбиває застосунок на набір невеликих, незалежно розгорнутих сервісів, кожен з яких відповідає за конкретну бізнес-функцію. Ці сервіси взаємодіють між собою через чітко визначені інтерфейси, зазвичай використовуючи легковагові протоколи, такі як HTTP/REST.

**Відмінності від клієнт-серверної архітектури:**

- **Гранулярність:** Мікросервіси розбивають серверну частину на дрібні, незалежні компоненти, тоді як традиційна клієнт-серверна модель може мати монолітний сервер.
- **Незалежність розгортання:** Кожен мікросервіс може розгортатися, масштабуватися та оновлюватися незалежно від інших.

**Переваги:**

- **Масштабованість:** Можливість масштабувати окремі сервіси залежно від навантаження.
- **Гнучкість у розробці:** Команди можуть працювати незалежно одна від одної, вибираючи найбільш підходящі технології та інструменти для кожного сервісу.
- **Підвищена стійкість:** Збій одного сервісу не призводить до відмови всього застосунку.
- **Простота підтримки та розширення:** Нові функціональності можуть додаватися шляхом створення нових сервісів без впливу на існуючі.

**Недоліки:**

- **Складність управління:** Координація та моніторинг великої кількості сервісів можуть бути складними.
- **Підвищені вимоги до інфраструктури:** Потрібна розвинена інфраструктура для управління контейнерами, оркестрації, виявлення сервісів тощо.
- **Ускладнення тестування:** Тестування взаємодії між сервісами може бути складнішим, ніж у монолітних системах.
- **Мережеві накладні витрати:** Збільшення кількості мережевих викликів між сервісами може вплинути на продуктивність.

------

#### 4. **Сервісно-орієнтована архітектура (SOA)**

**Опис:** SOA передбачає побудову застосунків як набір взаємодіючих сервісів, які надають визначені бізнес-функції через стандартизовані інтерфейси та протоколи. Сервіси в SOA зазвичай більші та менш гранулярні, ніж у мікросервісній архітектурі.

**Відмінності від клієнт-серверної архітектури:**

- **Розподіленість та повторне використання:** SOA орієнтована на створення сервісів, які можуть бути повторно використані в різних додатках та бізнес-процесах.
- **Стандартизація:** Використання загальних стандартів та протоколів (наприклад, SOAP, WSDL) для забезпечення взаємодії між сервісами.

**Переваги:**

- **Повторне використання сервісів:** Можливість використовувати один і той самий сервіс у різних контекстах та додатках.
- **Гнучкість бізнес-процесів:** Швидке адаптування до змін бізнес-вимог шляхом комбінування існуючих сервісів.
- **Масштабованість та надійність:** Розподіленість сервісів дозволяє ефективно масштабувати систему та підвищувати її стійкість до збоїв.

**Недоліки:**

- **Складність реалізації:** Впровадження SOA вимагає значних зусиль у плануванні, проектуванні та управлінні сервісами.
- **Продуктивність:** Використання важковагових протоколів (наприклад, SOAP) може призводити до збільшення накладних витрат та зниження швидкодії.
- **Вартість:** Потребує інвестицій у відповідні інструменти та інфраструктуру.
- **Безпека:** Забезпечення безпеки при взаємодії між різними сервісами може бути складним завданням.

------

#### 5. **Подієво-орієнтована архітектура (Event-Driven Architecture, EDA)**

**Опис:** У подієво-орієнтованій архітектурі компоненти системи спілкуються між собою шляхом обміну подіями. Кожен компонент реагує на події, що відбуваються в системі, і, у свою чергу, може генерувати нові події.

**Відмінності від клієнт-серверної архітектури:**

- **Асинхронність:** Взаємодія між компонентами відбувається асинхронно через події, на відміну від синхронних запитів-відповідей у клієнт-серверній моделі.
- **Слабка зв'язаність:** Компоненти не залежать безпосередньо один від одного, що підвищує гнучкість системи.

**Переваги:**

- **Масштабованість:** Легко обробляє велику кількість подій та навантаження, додаючи нові обробники подій.
- **Швидкість реакції:** Система може швидко реагувати на зміни та події в реальному часі.
- **Гнучкість та розширюваність:** Нові функціональності можуть бути додані без впливу на існуючі компоненти.
- **Стійкість до збоїв:** Збій одного обробника подій не впливає на роботу інших частин системи.

**Недоліки:**

- **Складність відстеження потоку даних:** Важко відстежувати послідовність подій та їхній вплив на систему.
- **Відладка та тестування:** Ускладнені через асинхронний характер взаємодії.
- **Потенційна надмірність:** Неконтрольоване генерування подій може призвести до перевантаження системи.
- **Забезпечення послідовності даних:** Важко гарантувати консистентність даних у розподіленому середовищі.

------

#### 6. **Шарова архітектура (Layered Architecture)**

**Опис:** Шарова архітектура розбиває систему на ієрархічні шари, де кожен шар відповідає за певний набір функцій та взаємодіє лише з сусідніми шарами. Типовим прикладом є поділ на презентаційний шар, шар бізнес-логіки та шар доступу до даних.

**Відмінності від клієнт-серверної архітектури:**

- **Внутрішня організація:** Шарова архітектура описує внутрішню структуру додатку, тоді як клієнт-серверна модель фокусується на розподілі функціональності між різними машинами.
- **Структурна абстракція:** Шари забезпечують рівні абстракції та інкапсуляції логіки.

**Переваги:**

- **Модульність:** Легко розробляти, тестувати та підтримувати окремі шари.
- **Повторне використання коду:** Компоненти шарів можуть бути повторно використані в інших проєктах.
- **Зрозуміла структура:** Чіткий поділ відповідальностей полегшує розуміння та управління системою.

**Недоліки:**

- **Зниження продуктивності:** Проходження запиту через кілька шарів може збільшити час обробки.
- **Складність змін:** Зміни в нижніх шарах можуть вимагати змін у верхніх шарах.
- **Надмірна бюрократія:** Може призвести до надмірного ускладнення простої логіки.

------

#### 7. **Архітектура Model-View-Controller (MVC)**

**Опис:** MVC розділяє додаток на три основні компоненти:

- **Model (Модель):** Управляє даними та бізнес-логікою.
- **View (Вид):** Відповідає за відображення даних користувачу.
- **Controller (Контролер):** Обробляє вхідні запити та координує взаємодію між моделлю та видом.

**Відмінності від клієнт-серверної архітектури:**

- **Внутрішній патерн:** MVC визначає структуру всередині додатку, тоді як клієнт-серверна модель описує розподіл між різними системами.
- **Розділення обов'язків:** MVC забезпечує чіткий поділ між обробкою даних, логікою та відображенням.

**Переваги:**

- **Модульність та підтримуваність:** Легше підтримувати та оновлювати окремі компоненти без впливу на інші.
- **Повторне використання коду:** Компоненти можна повторно використовувати в різних частинах застосунку.
- **Паралельна розробка:** Різні команди можуть працювати над моделлю, видом та контролером одночасно.

**Недоліки:**

- **Складність:** Може бути надмірно складним для невеликих проєктів.
- **Підвищені вимоги до планування:** Потрібно ретельно планувати взаємодію між компонентами.
- **Потенційні проблеми з продуктивністю:** Неправильна реалізація може призвести до зниження продуктивності.

------

#### 8. **Серверлес-архітектура (Serverless Architecture)**

**Опис:** У серверлес-архітектурі розробники пишуть та розгортають код без необхідності управління серверами. Провайдер хмарних послуг (наприклад, AWS Lambda, Azure Functions) автоматично керує виконанням, масштабуванням та інфраструктурою.

**Відмінності від клієнт-серверної архітектури:**

- **Відсутність керованих серверів:** Розробники не займаються налаштуванням та підтримкою серверів, фокусуючись лише на бізнес-логіці.
- **Оплата за використання:** Оплата здійснюється лише за фактичне використання ресурсів, а не за постійно працюючі сервери.

**Переваги:**

- **Зниження витрат:** Оплата тільки за спожиті ресурси, без витрат на простої.
- **Автоматичне масштабування:** Система автоматично масштабується в залежності від навантаження.
- **Швидке розгортання:** Можливість швидко розгорнути та оновити функціональність.
- **Фокус на бізнес-логіці:** Розробники можуть зосередитися на функціоналі, не турбуючись про інфраструктуру.

**Недоліки:**

- **Обмеження продуктивності:** Може бути затримка при "холодному старті" функцій.
- **Залежність від провайдера:** Перенесення застосунку між провайдерами може бути складним.
- **Обмежені можливості налаштування:** Менше контролю над середовищем виконання.
- **Проблеми з відлагодженням та моніторингом:** Може бути складніше відслідковувати та діагностувати помилки.

------

#### 9. **Хмарна архітектура (Cloud Architecture)**

**Опис:** Хмарна архітектура використовує ресурси та сервіси, надані хмарними провайдерами (AWS, Azure, Google Cloud) для розробки, розгортання та управління застосунками. Це може включати в себе використання різних моделей обслуговування: IaaS (Infrastructure as a Service), PaaS (Platform as a Service), SaaS (Software as a Service).

**Відмінності від клієнт-серверної архітектури:**

- **Розташування ресурсів:** Ресурси розміщені в хмарі та доступні через інтернет, що забезпечує високу доступність та масштабованість.
- **Модель обслуговування:** Розробники можуть вибирати рівень абстракції та контролю над інфраструктурою залежно від потреб.

**Переваги:**

- **Масштабованість:** Легке масштабування ресурсів в залежності від потреб.
- **Гнучкість:** Швидке розгортання та конфігурування сервісів.
- **Зниження витрат:** Оплата за спожиті ресурси, відсутність капітальних витрат на інфраструктуру.
- **Висока доступність та надійність:** Хмарні провайдери забезпечують резервування та відмовостійкість.

**Недоліки:**

- **Безпека та конфіденційність:** Потрібно ретельно забезпечувати безпеку даних, розміщених у хмарі.
- **Залежність від інтернет-з'єднання:** Якість та доступність сервісів залежить від стабільності інтернет-з'єднання.
- **Локальні законодавчі обмеження:** Можуть бути обмеження щодо зберігання даних у певних юрисдикціях.
- **Залежність від провайдера:** Перенесення сервісів між провайдерами може бути складним та затратним.

------

Кожна з описаних архітектур має свої унікальні характеристики, переваги та недоліки. Вибір відповідної архітектури залежить від специфічних вимог проєкту, таких як масштабованість, продуктивність, гнучкість, складність розробки та підтримки, а також фінансові та часові обмеження. Розуміння різних архітектурних підходів дозволяє розробникам та архітекторам створювати ефективні, надійні та стійкі програмні рішення, що відповідають потребам бізнесу та користувачів.



### Ключові компоненти клієнт-серверної архітектури

Клієнт-серверна архітектура складається з трьох основних компонентів: клієнта, сервера та мережі. Кожен з цих компонентів відіграє ключову роль у забезпеченні функціонування та ефективності системи, взаємодіючи між собою для виконання завдань, поставлених користувачем. Розглянемо кожен з цих компонентів детальніше.

#### Клієнт

**Типи клієнтів**

Клієнт у клієнт-серверній архітектурі є компонентом, який ініціює запити до сервера для отримання або передачі даних. Існує кілька типів клієнтів, які можуть використовуватися в різних сценаріях:

1. **Тонкий клієнт (Thin Client):**
   - **Опис:** Тонкий клієнт виконує мінімальну кількість обчислень та забезпечує інтерфейс для взаємодії користувача з сервером. Вся обробка даних та виконання бізнес-логіки здійснюється на сервері. Тонкий клієнт зазвичай реалізується у вигляді веб-браузера, який відображає інформацію, отриману від сервера.
   - **Приклади:** Веб-браузери (Google Chrome, Mozilla Firefox), віддалені робочі стільниці.
   - **Роль:** Зосереджує свою діяльність на відображенні даних та прийомі вводу від користувача, передаючи всю важку обробку на сервер.

2. **Товстий клієнт (Thick Client):**
   - **Опис:** Товстий клієнт виконує значну частину обчислень та обробки даних на стороні клієнта, взаємодіючи з сервером лише для отримання або передачі необхідних даних. Такий підхід дозволяє зменшити навантаження на сервер та покращити швидкодію.
   - **Приклади:** Десктопні додатки (Microsoft Outlook, Adobe Photoshop), мобільні додатки (WhatsApp, Instagram).
   - **Роль:** Виконує більшу частину бізнес-логіки та обчислень локально, зменшуючи залежність від сервера.

3. **Гібридний клієнт:**
   - **Опис:** Гібридний клієнт поєднує характеристики тонкого та товстого клієнтів, виконуючи частину обчислень на клієнті, а частину на сервері. Такий підхід дозволяє оптимізувати використання ресурсів та забезпечити більшу гнучкість системи.
   - **Приклади:** Прогресивні веб-додатки (Progressive Web Apps, PWA), деякі корпоративні додатки з частковою офлайн-функціональністю.
   - **Роль:** Забезпечує оптимальний баланс між обчисленнями на стороні клієнта та сервера, залежно від потреб конкретного сценарію.

**Роль клієнта у взаємодії з сервером**

Клієнт відіграє важливу роль у клієнт-серверній архітектурі, оскільки він є точкою взаємодії кінцевого користувача з системою. Основні функції клієнта включають:

- **Ініціація запитів:** Клієнт формує запити на отримання або передачу даних, які відправляються серверу.
- **Відображення інформації:** Клієнт отримує дані від сервера та відображає їх у зрозумілому для користувача форматі.
- **Збір та передача даних:** Клієнт збирає ввід користувача (наприклад, дані форми) та передає їх на сервер для подальшої обробки.

#### Сервер

**Типи серверів**

Сервер у клієнт-серверній архітектурі відповідає за обробку запитів клієнта, управління даними та забезпечення виконання бізнес-логіки. Існує кілька типів серверів, залежно від їх призначення та функцій:

1. **Веб-сервер:**
   - **Опис:** Веб-сервер обробляє HTTP-запити від клієнтів (зазвичай веб-браузерів) і повертає відповідні веб-сторінки або інші веб-ресурси (зображення, відео, тощо).
   - **Приклади:** Apache HTTP Server, Nginx, Microsoft IIS.
   - **Роль:** Забезпечує доступ до веб-контенту та управління веб-ресурсами.

2. **Аплікаційний сервер:**
   - **Опис:** Аплікаційний сервер виконує бізнес-логіку та обробку даних, що знаходяться між веб-сервером і базою даних. Він забезпечує виконання складних операцій та інтеграцію різних компонентів системи.
   - **Приклади:** Apache Tomcat, JBoss, WebSphere.
   - **Роль:** Управляє бізнес-логікою, забезпечує інтеграцію та обробку запитів, що потребують складних обчислень.

3. **Сервер баз даних:**
   - **Опис:** Сервер баз даних зберігає та управляє даними, які використовуються клієнтами та іншими серверами. Він забезпечує ефективне зберігання, пошук, оновлення та обробку великих обсягів даних.
   - **Приклади:** MySQL, PostgreSQL, Oracle Database, MongoDB.
   - **Роль:** Забезпечує збереження та обробку структурованих даних, надає доступ до них через SQL-запити або інші механізми.

**Роль сервера у обробці запитів клієнтів**

Сервер є основним компонентом у клієнт-серверній архітектурі, який відповідає за обробку запитів від клієнтів і виконання всіх необхідних дій для надання відповіді. Основні функції сервера включають:

- **Обробка запитів:** Сервер отримує запити від клієнтів, інтерпретує їх і виконує необхідні операції, такі як доступ до бази даних або виконання бізнес-логіки.
- **Зберігання даних:** Сервер зберігає важливі дані та ресурси, забезпечуючи їх безпеку та цілісність.
- **Забезпечення безпеки:** Сервер виконує перевірку прав доступу, аутентифікацію та інші заходи безпеки для захисту даних та ресурсів.
- **Масштабованість та надійність:** Сервери можуть бути об'єднані в кластери або використовувати балансування навантаження для забезпечення стійкості системи та обробки великої кількості запитів.

#### Мережа

**Основні протоколи передачі даних**

Мережа є сполучною ланкою між клієнтом і сервером у клієнт-серверній архітектурі, яка забезпечує передачу даних та комунікацію між цими компонентами. Основні протоколи, що використовуються для передачі даних у мережі:

1. **HTTP/HTTPS:**
   - **Опис:** HTTP (Hypertext Transfer Protocol) є основним протоколом для передачі даних у веб-додатках. HTTPS (HTTP Secure) є його безпечною версією, що використовує шифрування для захисту даних.
   - **Роль:** Забезпечує передачу веб-сторінок, API-запитів та інших ресурсів між клієнтом і сервером. HTTPS додає шифрування для забезпечення конфіденційності та цілісності даних.

2. **TCP/IP:**
   - **Опис:** TCP/IP (Transmission Control Protocol/Internet Protocol) є базовим набором протоколів для передачі даних у мережі Інтернет. TCP забезпечує надійну передачу даних, а IP відповідає за маршрутизацію пакетів даних.
   - **Роль:** Забезпечує надійну, орієнтовану на з'єднання передачу даних між клієнтом і сервером, а також маршрутизацію даних через Інтернет.

3. **WebSocket:**
   - **Опис:** WebSocket — це протокол, який дозволяє встановлювати двостороннє з'єднання між клієнтом і сервером в режимі реального часу. Це дає можливість передавати дані без необхідності постійного відправлення HTTP-запитів.

   - **Роль:** Використовується для застосунків, що потребують передачі даних у реальному часі, таких як онлайн-ігри, чати, біржові платформи.

**Роль мережі у забезпеченні комунікації між клієнтом і сервером**

Мережа є критичним компонентом клієнт-серверної архітектури, оскільки вона забезпечує надійну передачу даних між клієнтом і сервером. Основні ролі мережі включають:

- **Передача даних:** Мережа відповідає за передачу запитів від клієнта до сервера та відповідей від сервера до клієнта. Це включає передачу всіх необхідних даних, таких як HTML-сторінки, зображення, відео, API-виклики та інші ресурси.
- **Маршрутизація:** Мережа забезпечує правильну доставку даних між клієнтом і сервером, використовуючи протоколи IP для маршрутизації пакетів даних через Інтернет.
- **Забезпечення безпеки:** Мережа використовує різні механізми, такі як шифрування, віртуальні приватні мережі (VPN), брандмауери та інші заходи для захисту даних під час їх передачі.
- **Масштабованість:** Мережа дозволяє обробляти велику кількість одночасних підключень та забезпечує надійність і швидкодію системи шляхом використання методів, таких як балансування навантаження та CDN (Content Delivery Network).

Таким чином, клієнт, сервер і мережа є основними компонентами клієнт-серверної архітектури, кожен з яких відіграє важливу роль у забезпеченні ефективності, масштабованості та надійності системи. Розуміння їхніх функцій та взаємодії є ключовим для успішного проєктування та розробки сучасних інформаційних систем.



### Типи клієнт-серверної архітектури

Клієнт-серверна архітектура може бути реалізована в різних формах залежно від специфіки додатку, вимог до продуктивності, масштабованості та підтримки. Найпоширенішими типами клієнт-серверної архітектури є дворівнева, трьохрівнева, мікросервісна та серверлес-архітектура. Нижче наведено опис, приклади, переваги та недоліки кожного з цих підходів.

#### Дворівнева архітектура

**Опис:**

Дворівнева архітектура є найбільш простою формою клієнт-серверної архітектури, де взаємодія відбувається між двома рівнями: клієнтом і сервером. Клієнтська частина містить інтерфейс користувача та деякі бізнес-логічні обчислення, тоді як сервер обробляє запити клієнта, зберігає дані та виконує основну бізнес-логіку.

**Приклади:**

- **Класичні настільні додатки:** додатки, які безпосередньо взаємодіють з базою даних, наприклад, клієнт-серверні системи обліку або деякі корпоративні системи управління ресурсами (ERP).
- **Прості веб-додатки:** Веб-додатки, де клієнтський код виконується на стороні браузера, а сервер відповідає за обробку запитів та взаємодію з базою даних.

**Переваги:**

- **Простота:** Архітектура легко реалізується та підтримується через невелику кількість компонентів.
- **Швидка розробка:** Завдяки простій структурі, час розробки скорочується.
- **Менше вимог до інфраструктури:** Відсутність складної інфраструктури дозволяє знизити витрати на розгортання та обслуговування.

**Недоліки:**

- **Обмежена масштабованість:** Збільшення кількості користувачів може призвести до зниження продуктивності, оскільки один сервер може бути перевантажений запитами.
- **Вразливість до збоїв:** Якщо сервер виходить з ладу, весь додаток перестає працювати.
- **Обмежена гнучкість:** Важко адаптуватися до змін в бізнес-вимогах без серйозних модифікацій архітектури.

#### Трьохрівнева архітектура

**Опис:**

Трьохрівнева архітектура розділяє додаток на три окремі рівні: рівень презентації (Presentation Layer), рівень бізнес-логіки (Application Layer), та рівень даних (Data Layer). Така архітектура дозволяє кожному рівню виконувати свою специфічну роль, забезпечуючи чіткий поділ функціональності.

- **Рівень презентації:** Відповідає за інтерфейс користувача, відображення даних та прийом введених користувачем команд.
- **Рівень бізнес-логіки:** Обробляє бізнес-логіку та правила, виконує обчислення та приймає рішення.
- **Рівень даних:** Відповідає за зберігання та управління даними, взаємодіючи з базами даних.

**Приклади:**

- **Веб-додатки з використанням MVC патерну:** Веб-додатки, побудовані за моделлю MVC (Model-View-Controller), де кожен компонент відповідає певному рівню архітектури.
- **Складні корпоративні додатки:** Додатки, які потребують чіткої організації бізнес-логіки, наприклад, CRM та ERP системи.

**Переваги:**

- **Масштабованість:** Кожен рівень можна масштабувати окремо, що дозволяє оптимізувати використання ресурсів.
- **Гнучкість:** Зміни на одному рівні не впливають на інші рівні, що спрощує підтримку та розвиток системи.
- **Модульність:** Чіткий поділ на рівні спрощує тестування, впровадження нових функціональностей та повторне використання компонентів.

**Недоліки:**

- **Складність реалізації:** Розробка трьохрівневої архітектури потребує більше часу та ресурсів через складність структури.
- **Затримки в комунікації:** Передача даних між рівнями може створювати затримки, що може вплинути на продуктивність.
- **Вищі витрати на інфраструктуру:** Потрібно більше серверів та ресурсів для підтримки кожного рівня.

#### Мікросервісна архітектура

**Опис:**

Мікросервісна архітектура полягає у розділенні додатка на набір невеликих, незалежно розгорнутих сервісів, кожен з яких виконує певну бізнес-функцію. Кожен мікросервіс є самостійним додатком зі своєю базою даних, бізнес-логікою та інтерфейсами API для взаємодії з іншими сервісами.

**Взаємодія через API:**

Мікросервіси взаємодіють між собою через API, зазвичай використовуючи легковагові протоколи, такі як REST або gRPC. Це забезпечує незалежність сервісів і дозволяє їм взаємодіяти навіть якщо вони розроблені на різних технологіях.

**Переваги:**

- **Масштабованість:** Кожен мікросервіс може бути незалежно масштабований, що дозволяє ефективно використовувати ресурси.
- **Гнучкість у розробці:** Команди можуть розробляти, розгортати та підтримувати мікросервіси незалежно одна від одної.
- **Стійкість:** Помилка в одному мікросервісі не призводить до відмови всього додатка, що підвищує загальну надійність системи.
- **Швидке впровадження змін:** Завдяки незалежності мікросервісів, нові функціональності можуть бути швидко додані без впливу на інші частини системи.

**Недоліки:**

- **Складність управління:** Координація великої кількості мікросервісів потребує складних систем оркестрації, таких як Kubernetes.
- **Накладні витрати на комунікацію:** Взаємодія між мікросервісами через мережу може створювати додаткові накладні витрати та затримки.
- **Проблеми з консистентністю даних:** Кожен мікросервіс має свою базу даних, що може ускладнити забезпечення цілісності даних в масштабах всієї системи.

#### Архітектура на основі серверлес-технологій

**Опис:**

Серверлес-архітектура (Serverless) дозволяє розробникам створювати та запускати додатки без необхідності управління інфраструктурою серверів. В цьому підході вся обробка даних виконується на функціях, які автоматично масштабуються та запускаються на вимогу. В хмарних середовищах серверлес-архітектура зазвичай використовується з функціями, що запускаються у відповідь на події (наприклад, HTTP-запити, зміни в базі даних тощо).

**Основні концепції:**

- **Функції як сервіс (FaaS):** Модель, при якій бізнес-логіка додатку розбивається на окремі функції, що виконуються на вимогу, без постійного резервування серверних ресурсів.
- **Автоматичне масштабування:** Інфраструктура автоматично масштабує кількість інстанцій функцій в залежності від навантаження, забезпечуючи ефективне використання ресурсів.
- **Оплата за використання:** Користувачі платять тільки за час виконання функцій, що значно знижує витрати на інфраструктуру.

**Приклади використання:**

- **AWS Lambda:** Функції AWS Lambda виконуються на вимогу в хмарному середовищі, дозволяючи запускати код у відповідь на події без необхідності управління серверами.
- **Google Cloud Functions:** Схожий сервіс від Google, який дозволяє створювати серверлес-функції для виконання обробки подій.

**Переваги:**

- **Зниження витрат:** Оплата здійснюється тільки за фактичний час виконання функцій, що значно знижує загальні витрати на інфраструктуру.
- **Автоматичне масштабування:** Додаток автоматично масштабується в залежності від кількості запитів, забезпечуючи стабільну роботу при високих навантаженнях.
- **Фокус на бізнес-логіці:** Розробники можуть зосередитися на розробці бізнес-логіки, не турбуючись про інфраструктуру та управління серверами.

**Недоліки:**

- **Обмеження продуктивності:** Іноді може виникати затримка при запуску функцій, особливо при "холодному старті".
- **Залежність від провайдера:** Залежність від конкретного хмарного провайдера може створити складності при перенесенні додатка на іншу платформу.
- **Обмежена конфігурація:** Менше контролю над середовищем виконання, що може бути проблематичним для деяких спеціалізованих додатків.

---

### Інші типи архітектур

#### Монолітна архітектура

**Опис:**
Монолітна архітектура передбачає, що весь додаток, включаючи бізнес-логіку, інтерфейс користувача і доступ до даних, розміщений в одному цілісному додатку. Всі компоненти тісно пов'язані між собою і виконуються в одному середовищі.

**Приклади:**
- Традиційні десктопні програми.
- Веб-додатки, де фронтенд і бекенд реалізовані в одному кодовому базі.

**Переваги:**
- Простота розробки і тестування.
- Легкість розгортання і підтримки.
- Висока продуктивність при невеликих навантаженнях.

**Недоліки:**
- Обмежена масштабованість.
- Складність при внесенні змін.
- Вразливість до збоїв.

#### Архітектура Model-View-Controller (MVC)

**Опис:**
MVC розділяє додаток на три компоненти: Model (дані та бізнес-логіка), View (інтерфейс користувача) і Controller (обробка запитів). Така архітектура сприяє модульності та повторному використанню коду.

**Приклади:**
- Веб-додатки, побудовані на фреймворках, таких як Django, Ruby on Rails.

**Переваги:**
- Чітке розділення відповідальності.
- Легкість у тестуванні та підтримці.
- Паралельна розробка різних компонентів.

**Недоліки:**
- Може бути надмірно складною для простих додатків.
- Затримки через необхідність передачі даних між компонентами.

Ці архітектурні підходи демонструють широкий спектр можливостей, які можуть бути використані для побудови сучасних клієнт-серверних систем. Вибір конкретної архітектури залежить від вимог проекту, масштабу системи, вимог до продуктивності та інших факторів.





### Приклади реальних клієнт-серверних систем

Клієнт-серверна архітектура є основою для багатьох сучасних додатків та систем, які ми використовуємо щодня. Вона дозволяє організувати ефективну взаємодію між користувачем і центральними серверами, забезпечуючи швидкий доступ до даних, високу продуктивність і масштабованість. Розглянемо декілька типових прикладів, де використовується клієнт-серверна архітектура: веб-додатки, мобільні додатки та корпоративні системи.

#### Веб-додатки

**Огляд популярних веб-сервісів**

Веб-додатки є однією з найбільш поширених реалізацій клієнт-серверної архітектури. Вони дозволяють користувачам взаємодіяти з додатком через веб-браузер, який виступає в ролі клієнта, а серверна частина обробляє запити, виконує бізнес-логіку та зберігає дані. Основними перевагами веб-додатків є доступність з будь-якого пристрою, підключеного до Інтернету, та можливість централізованого оновлення й підтримки додатку.

**Приклади популярних веб-додатків:**

- **Google Docs:** Веб-додаток для створення, редагування та спільного використання документів у реальному часі. Клієнтська частина, що виконується в браузері, відправляє запити на сервери Google для збереження та синхронізації документів. Сервер забезпечує обробку запитів, зберігання документів у хмарі та надання доступу до них для інших користувачів.

- **Facebook:** Соціальна мережа, де користувачі взаємодіють через веб-додаток, що завантажується в браузері. Клієнт відправляє запити на сервери Facebook для завантаження стрічки новин, публікації постів, обміну повідомленнями тощо. Сервер обробляє ці запити, управляє базами даних користувачів, контентом та забезпечує швидкий відгук для великої кількості користувачів.

- **Amazon:** Веб-додаток для електронної комерції, де користувачі можуть переглядати, шукати та купувати товари. Клієнтська частина взаємодіє з сервером, який обробляє запити на пошук товарів, управління кошиком, оформлення замовлення, а також здійснює обробку платежів та відстеження замовлень.

**Як використовується клієнт-серверна архітектура:**

У всіх цих прикладах клієнт-серверна архітектура дозволяє розподілити функції між клієнтом та сервером, забезпечуючи швидкий та ефективний доступ до даних, масштабованість системи для підтримки великої кількості користувачів, а також можливість централізованого зберігання та управління даними. Веб-додатки можуть бути легко розгорнуті та оновлені, оскільки всі зміни вносяться на сервері, без необхідності оновлювати клієнтське програмне забезпечення.

#### Мобільні додатки

**Взаємодія мобільних додатків з серверами**

Мобільні додатки є ще одним прикладом використання клієнт-серверної архітектури. Мобільні додатки встановлюються на смартфони або планшети, де вони виконують роль клієнта. Взаємодія з сервером здійснюється через API-запити, які мобільний додаток відправляє для отримання або відправлення даних.

**Приклади мобільних додатків:**

- **Instagram:** Соціальна мережа для обміну фотографіями та відео. Клієнтська частина, встановлена на мобільному пристрої, відправляє запити на сервер для завантаження стрічки новин, публікації контенту, обміну повідомленнями та коментарями. Сервер обробляє ці запити, зберігає контент у хмарі та забезпечує доступ до нього для інших користувачів.

- **Uber:** Мобільний додаток для виклику таксі та замовлення поїздок. Клієнтська частина дозволяє користувачам замовляти поїздки, відстежувати рух автомобіля та оплачувати послуги. Сервер обробляє запити на виклик автомобіля, оптимізує маршрути, зберігає інформацію про поїздки та забезпечує обробку платежів.

- **Spotify:** Музичний стримінговий сервіс, який дозволяє користувачам слухати музику онлайн. Клієнтська частина відправляє запити на сервери Spotify для доступу до музичних треків, створення плейлистів та зберігання налаштувань користувача. Сервер відповідає за обробку запитів, управління ліцензіями, зберігання та трансляцію музичного контенту.

**Особливості взаємодії:**

Мобільні додатки мають особливості взаємодії з сервером, що відрізняє їх від традиційних веб-додатків. По-перше, мобільні додатки часто працюють в умовах обмеженого інтернет-з'єднання, тому вони повинні ефективно використовувати кешування та синхронізацію даних. По-друге, мобільні додатки повинні забезпечувати безпеку даних та конфіденційність користувача, оскільки вони часто містять чутливу інформацію, таку як особисті дані або платіжна інформація.

#### Корпоративні системи

**Використання клієнт-серверної архітектури у великих організаціях**

У великих організаціях клієнт-серверна архітектура використовується для створення комплексних інформаційних систем, які підтримують управління бізнес-процесами, зберігання та обробку великих обсягів даних, а також інтеграцію різних систем та підрозділів.

**Приклади корпоративних систем:**

- **SAP ERP:** Система управління ресурсами підприємства, яка охоплює всі основні бізнес-процеси, включаючи фінанси, виробництво, логістику, управління персоналом тощо. Клієнтська частина, яка може бути реалізована як десктопний додаток або веб-інтерфейс, дозволяє користувачам взаємодіяти з системою, виконуючи свої робочі завдання. Серверна частина обробляє запити, управляє базами даних та забезпечує виконання складних бізнес-процесів.

- **Salesforce:** Хмарна CRM-система, яка дозволяє компаніям управляти взаємовідносинами з клієнтами, автоматизувати продажі та маркетинг, а також аналізувати дані. Клієнтська частина може бути реалізована як веб-додаток або мобільний додаток, який взаємодіє з сервером для управління даними клієнтів, продажів та маркетингових кампаній. Серверна частина зберігає всі дані у хмарі та забезпечує інтеграцію з іншими системами.

- **Microsoft Dynamics 365:** Платформа для управління бізнес-процесами, яка включає модулі для управління фінансами, продажами, маркетингом, операціями та обслуговуванням клієнтів. Клієнтська частина, реалізована у вигляді веб-інтерфейсу або мобільного додатка, дозволяє співробітникам компанії взаємодіяти з системою для виконання своїх обов'язків. Серверна частина обробляє запити, управляє базами даних та забезпечує аналітику та звітність.

**Як використовується клієнт-серверна архітектура:**

У корпоративних системах клієнт-серверна архітектура дозволяє розподілити обробку даних між клієнтами та серверами, забезпечуючи масштабованість, надійність та безпеку системи. Центральні сервери управляють великими обсягами даних, забезпечують доступ до них для різних підрозділів та інтегрують різні компоненти системи. Це дозволяє великим організаціям ефективно управляти своїми ресурсами, автоматизувати бізнес-процеси та приймати обґрунтовані рішення на основі даних.

Клієнт-серверна архітектура є фундаментом для створення сучасних додатків та систем, які використовуються в різних сферах: від простих веб-додатків до складних корпоративних систем. Завдяки розподілу функціональності між клієнтом і сервером, ця архітектура забезпечує високу продуктивність, масштабованість і надійність, що робить її незамінною для побудови ефективних інформаційних систем.



### Заключення та обговорення

#### Підсумки лекції: основні висновки про клієнт-серверну архітектуру

На сьогоднішній лекції ми детально розглянули клієнт-серверну архітектуру, яка є основою для створення багатьох сучасних програмних систем. Ключові висновки, які можна зробити:

1. **Суть клієнт-серверної архітектури**: Це модель, де функції розподіляються між клієнтом і сервером. Клієнт ініціює запити та взаємодіє з сервером, який обробляє ці запити та забезпечує доступ до ресурсів і даних.

2. **Еволюція клієнт-серверної архітектури**: Від мейнфреймів до сучасних розподілених систем, клієнт-серверна архітектура пройшла значний шлях розвитку, адаптуючись до вимог зростаючих обсягів даних та потреб у продуктивності та масштабованості.

3. **Основні компоненти**: Ми розглянули основні компоненти клієнт-серверної архітектури — клієнт, сервер і мережу. Кожен з них має важливу роль у забезпеченні роботи системи, від прийому запитів до обробки та передачі даних.

4. **Типи клієнт-серверної архітектури**: Існують різні види архітектур, такі як дворівнева, трьохрівнева, мікросервісна та серверлес-архітектура, кожна з яких має свої особливості, переваги та недоліки. Вибір архітектури залежить від конкретних вимог проєкту.

5. **Приклади реальних систем**: Клієнт-серверна архітектура успішно використовується у веб-додатках, мобільних додатках та корпоративних системах, забезпечуючи ефективне управління даними, масштабованість та надійність.

Ці знання є фундаментом для подальшого розуміння та вивчення більш складних аспектів розробки клієнт-серверних систем. У наступних лекціях ми поглибимося в практичні аспекти створення та оптимізації таких систем, включаючи розробку RESTful API, управління безпекою та багато іншого.



### Архітектури програмних систем: детальний огляд

Архітектура програмних систем визначає спосіб організації компонентів системи та взаємодії між ними. Вибір архітектури впливає на продуктивність, масштабованість, підтримуваність та гнучкість програмного забезпечення. Розглянемо детально архітектуру Model-View-Controller (MVC) та інші поширені архітектурні підходи.

#### Model-View-Controller (MVC)

**Опис:**

MVC (Model-View-Controller) — це архітектурний патерн, який розділяє додаток на три основні компоненти:

- **Model (Модель):** Відповідає за управління даними додатку. Модель містить бізнес-логіку, правила та методи для роботи з даними. Вона також забезпечує доступ до бази даних або інших джерел даних та зберігає стан додатку.

- **View (Вид):** Відповідає за відображення даних користувачу. View приймає інформацію з моделі та відображає її у вигляді, зручному для взаємодії з користувачем. Вона не містить бізнес-логіки, а лише показує те, що надала модель.

- **Controller (Контролер):** Відповідає за обробку запитів користувача та управління взаємодією між Моделлю та Відом. Контролер приймає ввід від користувача, передає дані моделі для обробки, а потім оновлює вид відповідно до результатів обробки.

**Приклади:**

- **Веб-фреймворки:** Django (Python), Ruby on Rails (Ruby), ASP.NET MVC (C#), Spring MVC (Java).
- **Десктопні додатки:** Архітектура MVC часто використовується в десктопних додатках, таких як додатки на базі JavaFX.

**Переваги:**

- **Розділення обов’язків:** Кожен компонент відповідає за свою частину функціональності, що спрощує розробку, тестування та підтримку.
- **Модульність:** Моделі, види та контролери можуть бути розроблені та протестовані незалежно один від одного.
- **Повторне використання:** Компоненти можуть бути повторно використані в різних частинах додатка або в інших додатках.
- **Гнучкість:** Легкість у внесенні змін до окремих компонентів без впливу на інші.

**Недоліки:**

- **Складність:** Для простих додатків MVC може бути надмірно складним та важким у реалізації.
- **Часті оновлення:** Постійна потреба в оновленні видів при зміні моделей може ускладнити підтримку.
- **Підвищені вимоги до планування:** MVC вимагає ретельного планування взаємодії між компонентами.

---

#### Монолітна архітектура

**Опис:**

Монолітна архітектура передбачає, що всі компоненти додатка — бізнес-логіка, інтерфейс користувача, робота з базами даних — об'єднані в єдиний цілісний додаток, який виконується в одному середовищі.

**Приклади:**

- **Класичні веб-додатки:** Багато ранніх веб-додатків, таких як ранні версії WordPress або Joomla, є монолітними.
- **Десктопні додатки:** Додатки, як-от Microsoft Word або Excel.

**Переваги:**

- **Простота розробки:** Всі компоненти розробляються в одному середовищі, що спрощує процес розробки.
- **Легкість тестування:** Оскільки всі компоненти інтегровані в один додаток, тестування може бути простішим.
- **Висока продуктивність:** Всі компоненти працюють у межах одного процесу, що може знижувати накладні витрати на взаємодію.

**Недоліки:**

- **Складність масштабування:** Масштабування монолітного додатка зазвичай означає масштабування всього додатка, що може бути неефективним.
- **Складність підтримки:** Великі монолітні додатки стають важкими в підтримці через складність внесення змін без впливу на всю систему.
- **Вразливість до збоїв:** Помилка в одній частині додатка може призвести до відмови всього додатка.

---

#### Мікросервісна архітектура

**Опис:**

Мікросервісна архітектура розбиває додаток на набір незалежних сервісів, кожен з яких відповідає за певну функціональність або бізнес-процес. Кожен мікросервіс є самостійним і взаємодіє з іншими мікросервісами через стандартизовані API.

**Приклади:**

- **Netflix:** Використовує мікросервісну архітектуру для побудови своєї стримінгової платформи.
- **Amazon:** Застосовує мікросервіси для управління різними аспектами своєї електронної комерції.

**Переваги:**

- **Незалежне розгортання:** Кожен мікросервіс може бути розгорнутий незалежно від інших, що дозволяє швидше впроваджувати нові функціональності.
- **Масштабованість:** Кожен мікросервіс може бути масштабований окремо, що дозволяє оптимізувати використання ресурсів.
- **Стійкість:** Помилка в одному мікросервісі не впливає на роботу інших, що підвищує надійність системи.
- **Гнучкість у виборі технологій:** Команди можуть використовувати різні технології для кожного мікросервісу, залежно від потреби.

**Недоліки:**

- **Складність управління:** Потрібна складна інфраструктура для управління великою кількістю мікросервісів.
- **Мережеві накладні витрати:** Взаємодія між мікросервісами через мережу може збільшити час відгуку та створити додаткові затримки.
- **Проблеми з консистентністю даних:** Забезпечення узгодженості даних між мікросервісами може бути складним.

---

#### Сервісно-орієнтована архітектура (SOA)

**Опис:**

Сервісно-орієнтована архітектура (SOA) передбачає побудову додатків як набору взаємодіючих сервісів, які надають певні бізнес-функції через стандартизовані інтерфейси та протоколи.

**Приклади:**

- **Організаційні ERP системи:** Великі організації часто використовують SOA для інтеграції різних модулів ERP систем.
- **Інтеграційні платформи:** SOA використовується для інтеграції різних систем та сервісів, наприклад, у фінансових установах.

**Переваги:**

- **Повторне використання сервісів:** Сервіси можуть бути використані в різних додатках та бізнес-процесах.
- **Гнучкість:** Легке налаштування та зміна бізнес-процесів шляхом комбінування сервісів.
- **Інтеграція:** Легко інтегрувати різні системи та технології.

**Недоліки:**

- **Складність:** Вимагає значних зусиль для розробки та впровадження.
- **Продуктивність:** Використання важковагових протоколів, таких як SOAP, може знизити продуктивність.
- **Вартість:** Необхідні значні інвестиції в інфраструктуру та інструменти.

---

#### Архітектура Model-View-ViewModel (MVVM)

**Опис:**

MVVM — це архітектурний патерн, який, подібно до MVC, розділяє додаток на три компоненти:

- **Model (Модель):** Відповідає за дані та бізнес-логіку додатка.
- **View (Вид):** Відповідає за відображення даних користувачу.
- **ViewModel:** Посередник між Моделлю та Відом, який керує станом виду та обробкою логіки, специфічної для представлення даних.

**Приклади:**

 **WPF (Windows Presentation Foundation):** Використовує MVVM для побудови десктопних додатків.
- **Knockout.js:** JavaScript-фреймворк, що реалізує концепцію MVVM для веб-додатків.

**Переваги:**

- **Чітке розділення обов'язків:** Спрощує підтримку та розвиток додатка.
- **Двостороннє зв’язування даних:** Забезпечує автоматичне оновлення виду при зміні моделі.
- **Повторне використання:** ViewModel може бути повторно використаний для різних видів.

**Недоліки:**

- **Складність:** Може бути складним для реалізації, особливо для новачків.
- **Продуктивність:** Двостороннє зв'язування може створювати накладні витрати.

---

#### Архітектура «Цибулини» (Onion Architecture)

**Опис:**

Onion Architecture (Цибулинна архітектура) організовує систему у вигляді кількох шарів, де внутрішні шари не залежать від зовнішніх. Зазвичай, ядро складається з бізнес-логіки та моделей, а зовнішні шари включають інфраструктуру та інтерфейси.

**Приклади:**

- **Додатки з акцентом на доменній логіці:** Використовується в системах, де бізнес-логіка є центральною і повинна бути незалежною від інфраструктури.

**Переваги:**

- **Висока модульність:** Чітке розділення на шари сприяє модульності та незалежності компонентів.
- **Тестованість:** Внутрішні шари можна легко тестувати незалежно від зовнішніх компонентів.
- **Знижена залежність:** Мінімізація залежностей між компонентами зменшує ризик помилок при змінах.

**Недоліки:**

- **Складність:** Архітектура може бути важкою для розуміння та впровадження.
- **Вимоги до структури:** Потребує ретельного планування та дизайну для успішного впровадження.

---

#### Сервісно-керована архітектура (Service-Oriented Architecture, SOA)

**Опис:**

SOA є підходом до архітектури програмних систем, де функції реалізуються як окремі сервіси, що можуть взаємодіяти один з одним через певні інтерфейси (зазвичай через веб-служби).

**Приклади:**

- **Інтеграційні системи:** Використання SOA для інтеграції різних корпоративних додатків та платформ.

**Переваги:**

- **Масштабованість:** Легкість масштабування окремих сервісів.
- **Гнучкість:** Легкість в адаптації та інтеграції нових сервісів.
- **Повторне використання:** Сервіси можуть бути використані повторно в різних додатках.

**Недоліки:**

- **Складність:** Велика кількість сервісів може ускладнити управління та моніторинг.
- **Накладні витрати:** Використання веб-служб може знизити продуктивність через накладні витрати на комунікацію.

---

### Висновок

Кожна архітектура має свої переваги та недоліки, і вибір відповідного підходу залежить від багатьох факторів, таких як складність проєкту, вимоги до масштабованості, продуктивності та підтримки. Розуміння різних архітектурних патернів дозволяє розробникам створювати оптимальні рішення, що відповідають потребам бізнесу та користувачів.